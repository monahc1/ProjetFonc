# Functional vs. Imperative Data Structures Analysis ğŸŒ³ğŸ”

Welcome to our comprehensive project where we delve into the fascinating comparison between purely functional data structures (lists and trees) and their imperative counterparts. Our objective is to rigorously evaluate various aspects such as memory usage, performance, and the efficiency of parallelization, providing insightful analysis on each.

## ğŸ¯ Project Overview

This project aims to explore the implementation nuances and performance metrics of functional data structures in Haskell compared to imperative implementations in C++. We dissect:

- **ğŸ§  Memory Usage**: A detailed analysis of how memory allocation differs between functional and imperative data structures.
- **â± Performance**: We benchmark operations like insertion, deletion, and lookup to gauge efficiency.
- **ğŸš€ Parallelization Efficacy**: Assessing if parallelization offers tangible benefits in functional structures versus imperative ones.
- **ğŸŒŸ Added Value**: Discussing the inherent benefits of immutability, ease of reasoning, and safety in functional programming.

## ğŸ“‚ Project Structure

- **`/Cpp`**:
  - `bst.cpp`: Contains the C++ implementation of binary search trees alongside benchmarking procedures.
- **`/Haskell`**:
  - `BST.hs`: Showcases the Haskell implementation of binary search trees with integrated performance benchmarks.

